% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/linearizeNestedList.R
\name{linearizeNestedList}
\alias{linearizeNestedList}
\title{linearizeNestedList}
\usage{
linearizeNestedList(
  nList,
  linearizeDataFrames = FALSE,
  nameSep = "/",
  forceNames = FALSE
)
}
\arguments{
\item{nList}{The input \code{list}.}

\item{linearizeDataFrames}{Logical. TRUE the columns in \code{data.frame}s will the "linearized". Default \code{FALSE}.}

\item{nameSep}{Character to be the separation between names.  Default  "/".}

\item{forceNames}{Logical. TRUE will rename list elements. Default \code{FALSE}.}
}
\description{
Implements a recursive algorithm to linearize nested lists upto any arbitrary level of nesting.
}
\details{
Implements a recursive algorithm to linearize nested lists upto any
arbitrary level of nesting (limited by R's allowance for recursion-depth).
By linearization, it is meant to bring all list branches emanating from
any nth-nested trunk upto the top-level trunk s.t. the return value is a
simple non-nested list having all branches emanating from this top-level
branch.

Since dataframes are essentially lists a boolean option is provided to
switch on/off the linearization of dataframes. This has been found
desirable in the author's experience.
Also, one'd typically want to preserve names in the lists in a way as to
clearly denote the association of any list element to it's nth-level
history. As such we provide a clean and simple method of preserving names
information of list elements. The names at any level of nesting are
appended to the names of all preceding trunks using the \code{nameSep} option
string as the seperator. The default \code{/} has been chosen to mimic the unix
tradition of filesystem hierarchies. The default behavior works with
existing names at any n-th level trunk, if found; otherwise, coerces simple
numeric names corresponding to the position of a list element on the
nth-trunk. Note, however, that this naming pattern does not ensure unique
names for all elements in the resulting list. If the nested lists had
non-unique names in a trunk the same would be reflected in the final list.
Also, note that the function does not at all handle cases where \code{some}
names are missing and some are not.
Clearly, preserving the n-level hierarchy of branches in the element names
may lead to names that are too long. Often, only the depth of a list
element may only be important. To deal with this possibility a boolean
option called \code{forceNames} has been provided. forceNames shall drop all
original names in the lists and coerce simple numeric names which simply
indicate the position of an element at the nth-level trunk as well as all
preceding trunk numbers.
}
\examples{
\dontrun{
if(interactive()){
ml <- list(a = "a", 
          b = 1:3, 
          c = data.frame(x = runif(3), y = runif(3)), 
          d = list(a = list("a", "b"), 
                   b = list(list(1), list(2)))
 

linearizeNestedList(ml)
linearizeNestedList(ml, linearizeDataFrames = TRUE)
linearizeNestedList(ml, forceNames = TRUE)
linearizeNestedList(ml, forceNames = TRUE, nameSep = "_")
}
}
}
\references{
\url{https://sites.google.com/site/akhilsbehl/geekspace/articles/r/linearize_nested_lists_in_r}
}
\seealso{
\code{\link{unlist}}
}
\author{
Akhil S Bhel
}
