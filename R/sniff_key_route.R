#' Identify Key Routes in Citation Networks
#'
#' This function identifies and visualizes key citation routes within scientific
#' networks by analyzing the most significant citation paths between publications.
#' The algorithm is based on the main path analysis approach described in:
#' Liu JS, Lu LYY. An integrated approach for main path analysis: Development
#' of the Hirsch index as an example. Journal of the American Society for
#' Information Science and Technology. 2012;63(3):528-542.
#' https://doi.org/10.1002/asi.21692
#'
#' @param network A network object of class `tbl_graph` or `igraph` containing
#'   citation data, or a list object generated by `sniff_groups()` when
#'   `scope = "groups"`
#' @param scope Character string specifying the analysis scope. Must be either
#'   "network" (for full network analysis) or "groups" (for group-wise analysis
#'   of a grouped network)
#' @param citations_percentage Numeric value between 0 and 1 indicating the
#'   percentage of top-cited edges to consider for key route identification.
#'   Default is 1 (all edges)
#'
#' @return A list containing for each group:
#' \itemize{
#'   \item \code{plot} - A ggplot2 object visualizing the key citation route
#'   \item \code{data} - A tibble with publication details (name, TI, AU, PY)
#'         of nodes in the key route
#' }
#'
#' @details
#' The function performs the following steps based on the main path analysis methodology:
#' \enumerate{
#'   \item Converts the citation network to a line graph where edges become nodes
#'   \item Filters edges based on citation percentage threshold
#'   \item Identifies the largest connected component
#'   \item Calculates all simple paths between source and sink nodes
#'   \item Determines the main citation route using forward and backward propagation
#'   \item Extracts and visualizes the key citation path
#' }
#'
#' The algorithm implements an integrated approach for main path analysis as described
#' in Liu & Lu (2012), which combines structural analysis with citation metrics to
#' identify the most significant knowledge diffusion paths in scientific literature.
#'
#' @references
#' Liu JS, Lu LYY. An integrated approach for main path analysis: Development
#' of the Hirsch index as an example. Journal of the American Society for
#' Information Science and Technology. 2012;63(3):528-542.
#' https://doi.org/10.1002/asi.21692
#'
#' @examples
#' \dontrun{
#' # Load required packages
#' library(igraph)
#' library(tidygraph)
#' library(ggraph)
#'
#' # Example with network scope
#' result <- sniff_key_route(my_network, scope = "network", citations_percentage = 0.8)
#'
#' # Example with groups scope
#' grouped_network <- sniff_groups(data)
#' result <- sniff_key_route(grouped_network, scope = "groups")
#'
#' # Access results for a specific group
#' result$group_name$plot
#' result$group_name$data
#' }
#'
#' @export
#' @importFrom igraph V E ends degree components induced_subgraph
#' @importFrom igraph all_simple_paths neighbors graph_from_edgelist line_graph
#' @importFrom tidygraph activate
#' @importFrom dplyr filter mutate pull select
#' @importFrom tibble as_tibble
#' @importFrom stats na.omit quantile
#' @importFrom glue glue
sniff_key_route <- function(network, scope = "network", citations_percentage = 1) {
  # Input validation
  if (is.null(network)) {
    stop("Network data not found in groups object", call. = FALSE)
  }

  required_scope <- c("network", "groups")
  if (!scope %in% required_scope) {
    stop(glue::glue("scope must be: {paste(required_scope, collapse = ' or ')}"), call. = FALSE)
  }

  if (scope == "groups") {
    # Input validation for groups scope
    list_dimensions <- c("network", "pubs_by_year", "aggregate")
    if (!all(list_dimensions %in% names(network))) {
      stop(glue::glue("network file must be generated by sniff_groups()"), call. = FALSE)
    }
    net_data <- network$network
  } else {
    # Input validation for network scope
    if (!inherits(network, c("tbl_graph", "igraph"))) {
      stop("Input (network) must be a network object (tbl_graph or igraph)", call. = FALSE)
    }

    network |>
      tidygraph::activate(nodes) |>
      dplyr::mutate(group = "full_network") ->
      net_data
  }

  if (!is.numeric(citations_percentage)) {
    stop("Input (citations_percentage) must be a numeric vector", call. = FALSE)
  }

  h_citation <- citations_percentage

  # Get unique groups
  group <- tryCatch(
    {
      net_data |>
        tidygraph::activate(nodes) |>
        tibble::as_tibble() |>
        dplyr::pull("group") |>
        stats::na.omit() |>
        unique() |>
        sort() ->
        unique_groups

      unique_groups
    },
    error = function(e) {
      stop("Error extracting groups from network: ", e$message, call. = FALSE)
    }
  )

  if (length(group) == 0) {
    stop("No valid groups found for analysis", call. = FALSE)
  }

  res <- vector(mode = "list", length = length(group))
  names(res) <- group

  for (grp in seq_along(group)) {
    net_data |>
      tidygraph::activate(nodes) |>
      dplyr::filter(group == group[[grp]]) ->
      net_data_group

    if (is.null(igraph::E(net_data_group)$name)) {
      edge_name <- apply(as.data.frame(igraph::ends(net_data_group, igraph::E(net_data_group))), 1, paste, collapse = "->")
    }

    # Use igraph::line_graph() instead of make_line_graph()
    # linegraph <- igraph::line_graph(net_data_group)
    linegraph <- igraph::make_line_graph(net_data_group)

    igraph::V(linegraph)$edge_name <- edge_name

    degree <- igraph::degree(linegraph, mode = "in")
    cutoff <- stats::quantile(degree, probs = (1 - h_citation))
    v_filter <- igraph::V(linegraph)[degree >= cutoff]
    sub_graph <- igraph::induced_subgraph(linegraph, v_filter)

    comp <- igraph::components(sub_graph)
    big_comp <- which.max(comp$csize)
    comp_filter <- igraph::V(sub_graph)[comp$membership == big_comp]
    comp_graph <- igraph::induced_subgraph(sub_graph, comp_filter)

    source_edges <- igraph::V(comp_graph)[igraph::degree(comp_graph, mode = "in") == 0]
    sink_edges <- igraph::V(comp_graph)[igraph::degree(comp_graph, mode = "out") == 0]

    all_paths <- unlist(
      lapply(
        source_edges,
        function(source) {
          igraph::all_simple_paths(
            graph = comp_graph,
            from = source,
            to = sink_edges,
            mode = "out"
          )
        }
      ),
      recursive = FALSE
    )

    SPC <- tabulate(unlist(all_paths))

    igraph::V(comp_graph)$count <- SPC

    source_edges <- igraph::V(comp_graph)[igraph::degree(comp_graph, mode = "in") == 0]
    sink_edges <- igraph::V(comp_graph)[igraph::degree(comp_graph, mode = "out") == 0]

    start_nodes <- source_edges[source_edges$count == max(source_edges$count)]
    end_nodes <- sink_edges[sink_edges$count == max(sink_edges$count)]

    forward <- numeric(length(igraph::V(comp_graph)))
    visited_forward <- rep(FALSE, length(igraph::V(comp_graph)))

    start_idx <- match(start_nodes, igraph::V(comp_graph))
    forward[start_idx] <- 1
    visited_forward[start_idx] <- TRUE

    while (length(start_idx) > 0) {
      next_idx <- c()
      for (i in start_idx) {
        neighbors_idx <- igraph::neighbors(comp_graph, i, mode = "out")
        if (length(neighbors_idx) > 0) {
          neighbor_counts <- igraph::V(comp_graph)[neighbors_idx]$count
          max_count <- max(neighbor_counts)
          top_neighbors <- neighbors_idx[neighbor_counts == max_count]
          top_neighbors <- top_neighbors[!visited_forward[as.numeric(top_neighbors)]]
          next_idx <- c(next_idx, as.numeric(top_neighbors))
        }
      }
      if (length(next_idx) > 0) {
        forward[next_idx] <- 1
        visited_forward[next_idx] <- TRUE
      }
      start_idx <- unique(next_idx)
    }

    backward <- numeric(length(igraph::V(comp_graph)))
    visited_backward <- rep(FALSE, length(igraph::V(comp_graph)))

    end_idx <- match(end_nodes, igraph::V(comp_graph))
    backward[end_idx] <- 1
    visited_backward[end_idx] <- TRUE

    while (length(end_idx) > 0) {
      next_idx <- c()
      for (i in end_idx) {
        neighbors_idx <- igraph::neighbors(comp_graph, i, mode = "in")
        if (length(neighbors_idx) > 0) {
          neighbor_counts <- igraph::V(comp_graph)[neighbors_idx]$count
          max_count <- max(neighbor_counts)
          top_neighbors <- neighbors_idx[neighbor_counts == max_count]
          top_neighbors <- top_neighbors[!visited_backward[as.numeric(top_neighbors)]]
          next_idx <- c(next_idx, as.numeric(top_neighbors))
        }
      }
      if (length(next_idx) > 0) {
        backward[next_idx] <- 1
        visited_backward[next_idx] <- TRUE
      }
      end_idx <- unique(next_idx)
    }

    main_path <- as.numeric(backward | forward)

    igraph::V(comp_graph)$path <- main_path

    # Corrigir o acesso à variável path usando a sintaxe do igraph
    nodes_to_keep <- igraph::V(comp_graph)[igraph::V(comp_graph)$path == 1]

    subgraph_path <- igraph::induced_subgraph(comp_graph, vids = nodes_to_keep)

    edge_list <- do.call(rbind, strsplit(igraph::V(subgraph_path)$edge_name, "->"))

    node_graph <- igraph::graph_from_edgelist(edge_list, directed = TRUE)

    data_source <- gsub("_.*$", "", igraph::V(net_data_group)$DB[[1]])

    if (data_source == 'openalex') {
      net_data_group |>
        dplyr::filter(name %in% igraph::V(node_graph)$name) |>
        dplyr::select(.data$name, .data$TI, .data$AU, .data$PY) |>
        dplyr::mutate(name2 = paste(stringr::word(gsub("\\|.*", "", .data$AU), -1), .data$PY, sep = "_")) |>
        tibble::as_tibble() |>
        dplyr::select(.data$name, .data$name2, .data$TI) ->
        data_path
    } else { # WoS
      net_data_group |>
        dplyr::filter(name %in% igraph::V(node_graph)$name) |>
        dplyr::select(.data$name, .data$TI, .data$AU, .data$PY) |>
        dplyr::mutate(name2 = paste(stringr::word(sub(' ', '-', gsub("\\,.*", "", .data$AU)), 1), .data$PY, sep = "_")) |>
        tibble::as_tibble() |>
        dplyr::select(.data$name, .data$name2, .data$TI) ->
        data_path
    }

    
    node_graph |>
      tidygraph::as_tbl_graph() |>
      dplyr::left_join(data_path, by = 'name') |>
      ggraph::ggraph(layout = "tree") +
      ggraph::geom_edge_link(color = "gray50", width = 1) +
      ggraph::geom_node_point(color = "steelblue", size = 4) +
      ggrepel::geom_text_repel(ggplot2::aes(x = x, y = y, label = .data$name2),
        size = 4,
        min.segment.length = 0,
        box.padding = 0.5,
        max.overlaps = Inf
      ) +
      ggplot2::scale_y_reverse() +
      ggraph::theme_graph() +
      ggplot2::theme(plot.margin = ggplot2::unit(c(1, 1, 2, 1), "cm")) ->
      krp

    res[[grp]] <- list(plot = krp, data = data_path)
  }

  return(res)
}
