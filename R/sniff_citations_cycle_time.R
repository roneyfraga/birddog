#' Calculate Citation Cycle Time (CCT) indicator
#'
#' @description
#' Calculates the Citation Cycle Time (CCT) - the average citation cycle time -
#' to measure the pace of technological or scientific progress in a publication network.
#' Based on Kayal (1999) methodology, the indicator measures the median age of cited
#' publications, where lower values indicate faster technological replacement cycles.
#'
#' @param network Required. Network object containing publication data. For `scope = "groups"`:
#'   object returned by `sniff_groups()`. For `scope = "network"`: network object
#'   (`tbl_graph` or `igraph`).
#' @param scope Analysis scope. Either `"groups"` (default) for separate group analysis
#'   or `"network"` for complete network analysis.
#' @param start_year,end_year Start and end years for temporal analysis. If not specified,
#'   uses minimum and maximum years found in the data.
#' @param tracked_cr_py Pre-processed citation year data (optional). If provided,
#'   avoids recalculating this step.
#'
#' @details
#' The Citation Cycle Time (CCT) is calculated as:
#' \enumerate{
#'   \item For each publication, calculate the year difference between the publication and its references
#'   \item Calculate the median of these differences for each publication
#'   \item Calculate the mean of the medians for the group/network + 0.5 (Kayal adjustment)
#' }
#'
#' Lower CCT values indicate that publications are citing more recent work, suggesting
#' a faster pace of technological/scientific replacement.
#'
#' @return
#' A list with the following components:
#' \item{data}{Tibble with CCT data containing columns: group, year, index}
#' \item{plots}{List of ggplot2 plots showing temporal evolution of CCT for each group}
#' \item{years_range}{Vector with start and end years used in the analysis}
#' \item{tracked_cr_py}{Complete citation year data used in calculations}
#'
#' @references
#' Kayal AA, Waters RC. An empirical evaluation of the technology cycle time indicator
#' as a measure of the pace of technological progress in superconductor technology.
#' IEEE Transactions on Engineering Management. 1999;46(2):127â€“31. doi:10.1109/17.759138
#'
#' @examples
#' \dontrun{
#' # Group analysis
#' results <- sniff_citations_cycle_time(network_groups, scope = "groups")
#'
#' # Network analysis
#' results_network <- sniff_citations_cycle_time(complete_network, scope = "network")
#'
#' # Accessing results
#' cct_data <- results$data
#' plots <- results$plots
#'
#' # Specifying time period
#' results_period <- sniff_citations_cycle_time(
#'   network_groups,
#'   start_year = 2010,
#'   end_year = 2020
#' )
#' }
#'
#' @seealso
#' [sniff_groups()], [track_publications_year_from_references()], [indexes_plots()]
#'
#' @export
sniff_citations_cycle_time <- function(
  network,
  scope = "groups",
  start_year = NULL,
  end_year = NULL,
  tracked_cr_py = NULL) {
  # checks
  if (is.null(network)) {
    stop("Network data not found in groups object", call. = FALSE)
  }

  required_scope <- c("network", "groups")
  if (!scope %in% required_scope) {
    stop(glue::glue("scope must be: {paste(required_scope, collapse = ' or ')}"), call. = FALSE)
  }

  if (scope == "groups") {
    # Input validation for groups scope
    list_dimensions <- c("network", "pubs_by_year", "aggregate")
    if (!all(list_dimensions %in% names(network))) {
      stop(glue::glue("network file must be generated by sniff_groups()"), call. = FALSE)
    }
    net_data <- network$network
  } else { # network
    # Input validation for network scope
    if (!inherits(network, c("tbl_graph", "igraph"))) {
      stop("Input (network) must be a network object (tbl_graph or igraph)", call. = FALSE)
    }
    network |>
      tidygraph::activate(nodes) |>
      dplyr::mutate(group = "full_network") ->
      net_data
  }

  # Determine start_year and end_year if not provided
  if (is.null(start_year) || is.null(end_year)) {
    publication_years <- tryCatch(
      {
        igraph::V(net_data)$PY
      },
      error = function(e) {
        stop("Error accessing publication years from network: ", e$message, call. = FALSE)
      }
    )

    publication_years <- publication_years[!is.na(publication_years)]

    if (length(publication_years) == 0) {
      stop("No publication years found in network data", call. = FALSE)
    }

    if (is.null(start_year)) {
      start_year <- min(publication_years, na.rm = TRUE)
      message("Using minimum publication year as start_year: ", start_year)
    }

    if (is.null(end_year)) {
      end_year <- max(publication_years, na.rm = TRUE)
      message("Using maximum publication year as end_year: ", end_year)
    }
  }

  if (start_year >= end_year) {
    stop("start_year must be less than end_year", call. = FALSE)
  }

  # Get unique groups
  group <- tryCatch(
    {
      net_data |>
        tidygraph::activate(nodes) |>
        tibble::as_tibble() |>
        dplyr::pull("group") |>
        stats::na.omit() |>
        unique() |>
        sort()
    },
    error = function(e) {
      stop("Error extracting groups from network: ", e$message, call. = FALSE)
    }
  )

  if (length(group) == 0) {
    stop("No valid groups found for analysis", call. = FALSE)
  }

  if (is.null(tracked_cr_py)) {
    track_publications_year_from_references(net_data) ->
      tracked_publications_year_from_references
  } else {
    tracked_cr_py ->
      tracked_publications_year_from_references
  }

  years_seq <- start_year:end_year

  tracked_publications_year_from_references |>
    dplyr::left_join(net_data |> tidygraph::activate(nodes) |> tibble::as_tibble() |> dplyr::select(.data$name, .data$group), by = "name") |>
    tibble::rownames_to_column(var = "node") |>
    dplyr::filter(.data$group %in% !!group) |>
    dplyr::group_by(.data$group) |>
    dplyr::group_map(~ {
      purrr::map_dfr(years_seq, function(current_year) {
        .x |>
          dplyr::filter(.data$PY <= current_year) |>
          dplyr::mutate(diff = abs(.data$PY - .data$CR_PY)) ->
          current_data

        if (nrow(current_data) == 0) {
          return(tibble::tibble(index = NA, year = current_year, group = .y$group))
        }

        current_data |>
          dplyr::group_by(.data$node) |>
          dplyr::summarise(median = median(.data$diff, na.rm = TRUE)) |>
          dplyr::summarise(index = mean(.data$median, na.rm = TRUE) + 0.5) |>
          dplyr::pull(.data$index) ->
          cct_value

        tibble::tibble(index = cct_value, year = current_year, group = .y$group)
      })
    }, .keep = TRUE) ->
    cct_list

  names(cct_list) <- group

  # Create plots for each group
  plots_list <- purrr::map2(cct_list, group, \(x, y) indexes_plots(x, group_name = y, start_year, end_year, method = "cct"))

  dplyr::bind_rows(cct_list) |>
    dplyr::select("group", "year", "index") ->
    cct_data

  list(
    data = cct_data,
    plots = plots_list,
    years_range = c(start_year = start_year, end_year = end_year),
    tracked_cr_py = tracked_publications_year_from_references
  ) ->
    result

  return(result)
}
